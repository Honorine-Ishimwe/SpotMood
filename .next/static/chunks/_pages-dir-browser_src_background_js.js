/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_pages-dir-browser_src_background_js"],{

/***/ "(pages-dir-browser)/./node_modules/delaunay-fast/delaunay.js":
/*!************************************************!*\
  !*** ./node_modules/delaunay-fast/delaunay.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var Delaunay;\n\n(function() {\n  \"use strict\";\n\n  var EPSILON = 1.0 / 1048576.0;\n\n  function supertriangle(vertices) {\n    var xmin = Number.POSITIVE_INFINITY,\n        ymin = Number.POSITIVE_INFINITY,\n        xmax = Number.NEGATIVE_INFINITY,\n        ymax = Number.NEGATIVE_INFINITY,\n        i, dx, dy, dmax, xmid, ymid;\n\n    for(i = vertices.length; i--; ) {\n      if(vertices[i][0] < xmin) xmin = vertices[i][0];\n      if(vertices[i][0] > xmax) xmax = vertices[i][0];\n      if(vertices[i][1] < ymin) ymin = vertices[i][1];\n      if(vertices[i][1] > ymax) ymax = vertices[i][1];\n    }\n\n    dx = xmax - xmin;\n    dy = ymax - ymin;\n    dmax = Math.max(dx, dy);\n    xmid = xmin + dx * 0.5;\n    ymid = ymin + dy * 0.5;\n\n    return [\n      [xmid - 20 * dmax, ymid -      dmax],\n      [xmid            , ymid + 20 * dmax],\n      [xmid + 20 * dmax, ymid -      dmax]\n    ];\n  }\n\n  function circumcircle(vertices, i, j, k) {\n    var x1 = vertices[i][0],\n        y1 = vertices[i][1],\n        x2 = vertices[j][0],\n        y2 = vertices[j][1],\n        x3 = vertices[k][0],\n        y3 = vertices[k][1],\n        fabsy1y2 = Math.abs(y1 - y2),\n        fabsy2y3 = Math.abs(y2 - y3),\n        xc, yc, m1, m2, mx1, mx2, my1, my2, dx, dy;\n\n    /* Check for coincident points */\n    if(fabsy1y2 < EPSILON && fabsy2y3 < EPSILON)\n      throw new Error(\"Eek! Coincident points!\");\n\n    if(fabsy1y2 < EPSILON) {\n      m2  = -((x3 - x2) / (y3 - y2));\n      mx2 = (x2 + x3) / 2.0;\n      my2 = (y2 + y3) / 2.0;\n      xc  = (x2 + x1) / 2.0;\n      yc  = m2 * (xc - mx2) + my2;\n    }\n\n    else if(fabsy2y3 < EPSILON) {\n      m1  = -((x2 - x1) / (y2 - y1));\n      mx1 = (x1 + x2) / 2.0;\n      my1 = (y1 + y2) / 2.0;\n      xc  = (x3 + x2) / 2.0;\n      yc  = m1 * (xc - mx1) + my1;\n    }\n\n    else {\n      m1  = -((x2 - x1) / (y2 - y1));\n      m2  = -((x3 - x2) / (y3 - y2));\n      mx1 = (x1 + x2) / 2.0;\n      mx2 = (x2 + x3) / 2.0;\n      my1 = (y1 + y2) / 2.0;\n      my2 = (y2 + y3) / 2.0;\n      xc  = (m1 * mx1 - m2 * mx2 + my2 - my1) / (m1 - m2);\n      yc  = (fabsy1y2 > fabsy2y3) ?\n        m1 * (xc - mx1) + my1 :\n        m2 * (xc - mx2) + my2;\n    }\n\n    dx = x2 - xc;\n    dy = y2 - yc;\n    return {i: i, j: j, k: k, x: xc, y: yc, r: dx * dx + dy * dy};\n  }\n\n  function dedup(edges) {\n    var i, j, a, b, m, n;\n\n    for(j = edges.length; j; ) {\n      b = edges[--j];\n      a = edges[--j];\n\n      for(i = j; i; ) {\n        n = edges[--i];\n        m = edges[--i];\n\n        if((a === m && b === n) || (a === n && b === m)) {\n          edges.splice(j, 2);\n          edges.splice(i, 2);\n          break;\n        }\n      }\n    }\n  }\n\n  Delaunay = {\n    triangulate: function(vertices, key) {\n      var n = vertices.length,\n          i, j, indices, st, open, closed, edges, dx, dy, a, b, c;\n\n      /* Bail if there aren't enough vertices to form any triangles. */\n      if(n < 3)\n        return [];\n\n      /* Slice out the actual vertices from the passed objects. (Duplicate the\n       * array even if we don't, though, since we need to make a supertriangle\n       * later on!) */\n      vertices = vertices.slice(0);\n\n      if(key)\n        for(i = n; i--; )\n          vertices[i] = vertices[i][key];\n\n      /* Make an array of indices into the vertex array, sorted by the\n       * vertices' x-position. */\n      indices = new Array(n);\n\n      for(i = n; i--; )\n        indices[i] = i;\n\n      indices.sort(function(i, j) {\n        return vertices[j][0] - vertices[i][0];\n      });\n\n      /* Next, find the vertices of the supertriangle (which contains all other\n       * triangles), and append them onto the end of a (copy of) the vertex\n       * array. */\n      st = supertriangle(vertices);\n      vertices.push(st[0], st[1], st[2]);\n      \n      /* Initialize the open list (containing the supertriangle and nothing\n       * else) and the closed list (which is empty since we havn't processed\n       * any triangles yet). */\n      open   = [circumcircle(vertices, n + 0, n + 1, n + 2)];\n      closed = [];\n      edges  = [];\n\n      /* Incrementally add each vertex to the mesh. */\n      for(i = indices.length; i--; edges.length = 0) {\n        c = indices[i];\n\n        /* For each open triangle, check to see if the current point is\n         * inside it's circumcircle. If it is, remove the triangle and add\n         * it's edges to an edge list. */\n        for(j = open.length; j--; ) {\n          /* If this point is to the right of this triangle's circumcircle,\n           * then this triangle should never get checked again. Remove it\n           * from the open list, add it to the closed list, and skip. */\n          dx = vertices[c][0] - open[j].x;\n          if(dx > 0.0 && dx * dx > open[j].r) {\n            closed.push(open[j]);\n            open.splice(j, 1);\n            continue;\n          }\n\n          /* If we're outside the circumcircle, skip this triangle. */\n          dy = vertices[c][1] - open[j].y;\n          if(dx * dx + dy * dy - open[j].r > EPSILON)\n            continue;\n\n          /* Remove the triangle and add it's edges to the edge list. */\n          edges.push(\n            open[j].i, open[j].j,\n            open[j].j, open[j].k,\n            open[j].k, open[j].i\n          );\n          open.splice(j, 1);\n        }\n\n        /* Remove any doubled edges. */\n        dedup(edges);\n\n        /* Add a new triangle for each edge. */\n        for(j = edges.length; j; ) {\n          b = edges[--j];\n          a = edges[--j];\n          open.push(circumcircle(vertices, a, b, c));\n        }\n      }\n\n      /* Copy any remaining open triangles to the closed list, and then\n       * remove any triangles that share a vertex with the supertriangle,\n       * building a list of triplets that represent triangles. */\n      for(i = open.length; i--; )\n        closed.push(open[i]);\n      open.length = 0;\n\n      for(i = closed.length; i--; )\n        if(closed[i].i < n && closed[i].j < n && closed[i].k < n)\n          open.push(closed[i].i, closed[i].j, closed[i].k);\n\n      /* Yay, we're done! */\n      return open;\n    },\n    contains: function(tri, p) {\n      /* Bounding box test first, for quick rejections. */\n      if((p[0] < tri[0][0] && p[0] < tri[1][0] && p[0] < tri[2][0]) ||\n         (p[0] > tri[0][0] && p[0] > tri[1][0] && p[0] > tri[2][0]) ||\n         (p[1] < tri[0][1] && p[1] < tri[1][1] && p[1] < tri[2][1]) ||\n         (p[1] > tri[0][1] && p[1] > tri[1][1] && p[1] > tri[2][1]))\n        return null;\n\n      var a = tri[1][0] - tri[0][0],\n          b = tri[2][0] - tri[0][0],\n          c = tri[1][1] - tri[0][1],\n          d = tri[2][1] - tri[0][1],\n          i = a * d - b * c;\n\n      /* Degenerate tri. */\n      if(i === 0.0)\n        return null;\n\n      var u = (d * (p[0] - tri[0][0]) - b * (p[1] - tri[0][1])) / i,\n          v = (a * (p[1] - tri[0][1]) - c * (p[0] - tri[0][0])) / i;\n\n      /* If we're outside the tri, fail. */\n      if(u < 0.0 || v < 0.0 || (u + v) > 1.0)\n        return null;\n\n      return [u, v];\n    }\n  };\n\n  if(true)\n    module.exports = Delaunay;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kZWxhdW5heS1mYXN0L2RlbGF1bmF5LmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixLQUFLO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCLEdBQUc7QUFDN0I7QUFDQTs7QUFFQSxpQkFBaUIsR0FBRztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLEtBQUs7QUFDeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixLQUFLO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixLQUFLO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixLQUFLO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsR0FBRztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7O0FBRUEsNkJBQTZCLEtBQUs7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLLElBQTZCO0FBQ2xDO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsiL1VzZXJzL2ljZXNwaWNlL1Nwb3RNb29kXy9ub2RlX21vZHVsZXMvZGVsYXVuYXktZmFzdC9kZWxhdW5heS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRGVsYXVuYXk7XG5cbihmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIEVQU0lMT04gPSAxLjAgLyAxMDQ4NTc2LjA7XG5cbiAgZnVuY3Rpb24gc3VwZXJ0cmlhbmdsZSh2ZXJ0aWNlcykge1xuICAgIHZhciB4bWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICB5bWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICB4bWF4ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxuICAgICAgICB5bWF4ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxuICAgICAgICBpLCBkeCwgZHksIGRtYXgsIHhtaWQsIHltaWQ7XG5cbiAgICBmb3IoaSA9IHZlcnRpY2VzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgIGlmKHZlcnRpY2VzW2ldWzBdIDwgeG1pbikgeG1pbiA9IHZlcnRpY2VzW2ldWzBdO1xuICAgICAgaWYodmVydGljZXNbaV1bMF0gPiB4bWF4KSB4bWF4ID0gdmVydGljZXNbaV1bMF07XG4gICAgICBpZih2ZXJ0aWNlc1tpXVsxXSA8IHltaW4pIHltaW4gPSB2ZXJ0aWNlc1tpXVsxXTtcbiAgICAgIGlmKHZlcnRpY2VzW2ldWzFdID4geW1heCkgeW1heCA9IHZlcnRpY2VzW2ldWzFdO1xuICAgIH1cblxuICAgIGR4ID0geG1heCAtIHhtaW47XG4gICAgZHkgPSB5bWF4IC0geW1pbjtcbiAgICBkbWF4ID0gTWF0aC5tYXgoZHgsIGR5KTtcbiAgICB4bWlkID0geG1pbiArIGR4ICogMC41O1xuICAgIHltaWQgPSB5bWluICsgZHkgKiAwLjU7XG5cbiAgICByZXR1cm4gW1xuICAgICAgW3htaWQgLSAyMCAqIGRtYXgsIHltaWQgLSAgICAgIGRtYXhdLFxuICAgICAgW3htaWQgICAgICAgICAgICAsIHltaWQgKyAyMCAqIGRtYXhdLFxuICAgICAgW3htaWQgKyAyMCAqIGRtYXgsIHltaWQgLSAgICAgIGRtYXhdXG4gICAgXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNpcmN1bWNpcmNsZSh2ZXJ0aWNlcywgaSwgaiwgaykge1xuICAgIHZhciB4MSA9IHZlcnRpY2VzW2ldWzBdLFxuICAgICAgICB5MSA9IHZlcnRpY2VzW2ldWzFdLFxuICAgICAgICB4MiA9IHZlcnRpY2VzW2pdWzBdLFxuICAgICAgICB5MiA9IHZlcnRpY2VzW2pdWzFdLFxuICAgICAgICB4MyA9IHZlcnRpY2VzW2tdWzBdLFxuICAgICAgICB5MyA9IHZlcnRpY2VzW2tdWzFdLFxuICAgICAgICBmYWJzeTF5MiA9IE1hdGguYWJzKHkxIC0geTIpLFxuICAgICAgICBmYWJzeTJ5MyA9IE1hdGguYWJzKHkyIC0geTMpLFxuICAgICAgICB4YywgeWMsIG0xLCBtMiwgbXgxLCBteDIsIG15MSwgbXkyLCBkeCwgZHk7XG5cbiAgICAvKiBDaGVjayBmb3IgY29pbmNpZGVudCBwb2ludHMgKi9cbiAgICBpZihmYWJzeTF5MiA8IEVQU0lMT04gJiYgZmFic3kyeTMgPCBFUFNJTE9OKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWVrISBDb2luY2lkZW50IHBvaW50cyFcIik7XG5cbiAgICBpZihmYWJzeTF5MiA8IEVQU0lMT04pIHtcbiAgICAgIG0yICA9IC0oKHgzIC0geDIpIC8gKHkzIC0geTIpKTtcbiAgICAgIG14MiA9ICh4MiArIHgzKSAvIDIuMDtcbiAgICAgIG15MiA9ICh5MiArIHkzKSAvIDIuMDtcbiAgICAgIHhjICA9ICh4MiArIHgxKSAvIDIuMDtcbiAgICAgIHljICA9IG0yICogKHhjIC0gbXgyKSArIG15MjtcbiAgICB9XG5cbiAgICBlbHNlIGlmKGZhYnN5MnkzIDwgRVBTSUxPTikge1xuICAgICAgbTEgID0gLSgoeDIgLSB4MSkgLyAoeTIgLSB5MSkpO1xuICAgICAgbXgxID0gKHgxICsgeDIpIC8gMi4wO1xuICAgICAgbXkxID0gKHkxICsgeTIpIC8gMi4wO1xuICAgICAgeGMgID0gKHgzICsgeDIpIC8gMi4wO1xuICAgICAgeWMgID0gbTEgKiAoeGMgLSBteDEpICsgbXkxO1xuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgbTEgID0gLSgoeDIgLSB4MSkgLyAoeTIgLSB5MSkpO1xuICAgICAgbTIgID0gLSgoeDMgLSB4MikgLyAoeTMgLSB5MikpO1xuICAgICAgbXgxID0gKHgxICsgeDIpIC8gMi4wO1xuICAgICAgbXgyID0gKHgyICsgeDMpIC8gMi4wO1xuICAgICAgbXkxID0gKHkxICsgeTIpIC8gMi4wO1xuICAgICAgbXkyID0gKHkyICsgeTMpIC8gMi4wO1xuICAgICAgeGMgID0gKG0xICogbXgxIC0gbTIgKiBteDIgKyBteTIgLSBteTEpIC8gKG0xIC0gbTIpO1xuICAgICAgeWMgID0gKGZhYnN5MXkyID4gZmFic3kyeTMpID9cbiAgICAgICAgbTEgKiAoeGMgLSBteDEpICsgbXkxIDpcbiAgICAgICAgbTIgKiAoeGMgLSBteDIpICsgbXkyO1xuICAgIH1cblxuICAgIGR4ID0geDIgLSB4YztcbiAgICBkeSA9IHkyIC0geWM7XG4gICAgcmV0dXJuIHtpOiBpLCBqOiBqLCBrOiBrLCB4OiB4YywgeTogeWMsIHI6IGR4ICogZHggKyBkeSAqIGR5fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZHVwKGVkZ2VzKSB7XG4gICAgdmFyIGksIGosIGEsIGIsIG0sIG47XG5cbiAgICBmb3IoaiA9IGVkZ2VzLmxlbmd0aDsgajsgKSB7XG4gICAgICBiID0gZWRnZXNbLS1qXTtcbiAgICAgIGEgPSBlZGdlc1stLWpdO1xuXG4gICAgICBmb3IoaSA9IGo7IGk7ICkge1xuICAgICAgICBuID0gZWRnZXNbLS1pXTtcbiAgICAgICAgbSA9IGVkZ2VzWy0taV07XG5cbiAgICAgICAgaWYoKGEgPT09IG0gJiYgYiA9PT0gbikgfHwgKGEgPT09IG4gJiYgYiA9PT0gbSkpIHtcbiAgICAgICAgICBlZGdlcy5zcGxpY2UoaiwgMik7XG4gICAgICAgICAgZWRnZXMuc3BsaWNlKGksIDIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgRGVsYXVuYXkgPSB7XG4gICAgdHJpYW5ndWxhdGU6IGZ1bmN0aW9uKHZlcnRpY2VzLCBrZXkpIHtcbiAgICAgIHZhciBuID0gdmVydGljZXMubGVuZ3RoLFxuICAgICAgICAgIGksIGosIGluZGljZXMsIHN0LCBvcGVuLCBjbG9zZWQsIGVkZ2VzLCBkeCwgZHksIGEsIGIsIGM7XG5cbiAgICAgIC8qIEJhaWwgaWYgdGhlcmUgYXJlbid0IGVub3VnaCB2ZXJ0aWNlcyB0byBmb3JtIGFueSB0cmlhbmdsZXMuICovXG4gICAgICBpZihuIDwgMylcbiAgICAgICAgcmV0dXJuIFtdO1xuXG4gICAgICAvKiBTbGljZSBvdXQgdGhlIGFjdHVhbCB2ZXJ0aWNlcyBmcm9tIHRoZSBwYXNzZWQgb2JqZWN0cy4gKER1cGxpY2F0ZSB0aGVcbiAgICAgICAqIGFycmF5IGV2ZW4gaWYgd2UgZG9uJ3QsIHRob3VnaCwgc2luY2Ugd2UgbmVlZCB0byBtYWtlIGEgc3VwZXJ0cmlhbmdsZVxuICAgICAgICogbGF0ZXIgb24hKSAqL1xuICAgICAgdmVydGljZXMgPSB2ZXJ0aWNlcy5zbGljZSgwKTtcblxuICAgICAgaWYoa2V5KVxuICAgICAgICBmb3IoaSA9IG47IGktLTsgKVxuICAgICAgICAgIHZlcnRpY2VzW2ldID0gdmVydGljZXNbaV1ba2V5XTtcblxuICAgICAgLyogTWFrZSBhbiBhcnJheSBvZiBpbmRpY2VzIGludG8gdGhlIHZlcnRleCBhcnJheSwgc29ydGVkIGJ5IHRoZVxuICAgICAgICogdmVydGljZXMnIHgtcG9zaXRpb24uICovXG4gICAgICBpbmRpY2VzID0gbmV3IEFycmF5KG4pO1xuXG4gICAgICBmb3IoaSA9IG47IGktLTsgKVxuICAgICAgICBpbmRpY2VzW2ldID0gaTtcblxuICAgICAgaW5kaWNlcy5zb3J0KGZ1bmN0aW9uKGksIGopIHtcbiAgICAgICAgcmV0dXJuIHZlcnRpY2VzW2pdWzBdIC0gdmVydGljZXNbaV1bMF07XG4gICAgICB9KTtcblxuICAgICAgLyogTmV4dCwgZmluZCB0aGUgdmVydGljZXMgb2YgdGhlIHN1cGVydHJpYW5nbGUgKHdoaWNoIGNvbnRhaW5zIGFsbCBvdGhlclxuICAgICAgICogdHJpYW5nbGVzKSwgYW5kIGFwcGVuZCB0aGVtIG9udG8gdGhlIGVuZCBvZiBhIChjb3B5IG9mKSB0aGUgdmVydGV4XG4gICAgICAgKiBhcnJheS4gKi9cbiAgICAgIHN0ID0gc3VwZXJ0cmlhbmdsZSh2ZXJ0aWNlcyk7XG4gICAgICB2ZXJ0aWNlcy5wdXNoKHN0WzBdLCBzdFsxXSwgc3RbMl0pO1xuICAgICAgXG4gICAgICAvKiBJbml0aWFsaXplIHRoZSBvcGVuIGxpc3QgKGNvbnRhaW5pbmcgdGhlIHN1cGVydHJpYW5nbGUgYW5kIG5vdGhpbmdcbiAgICAgICAqIGVsc2UpIGFuZCB0aGUgY2xvc2VkIGxpc3QgKHdoaWNoIGlzIGVtcHR5IHNpbmNlIHdlIGhhdm4ndCBwcm9jZXNzZWRcbiAgICAgICAqIGFueSB0cmlhbmdsZXMgeWV0KS4gKi9cbiAgICAgIG9wZW4gICA9IFtjaXJjdW1jaXJjbGUodmVydGljZXMsIG4gKyAwLCBuICsgMSwgbiArIDIpXTtcbiAgICAgIGNsb3NlZCA9IFtdO1xuICAgICAgZWRnZXMgID0gW107XG5cbiAgICAgIC8qIEluY3JlbWVudGFsbHkgYWRkIGVhY2ggdmVydGV4IHRvIHRoZSBtZXNoLiAqL1xuICAgICAgZm9yKGkgPSBpbmRpY2VzLmxlbmd0aDsgaS0tOyBlZGdlcy5sZW5ndGggPSAwKSB7XG4gICAgICAgIGMgPSBpbmRpY2VzW2ldO1xuXG4gICAgICAgIC8qIEZvciBlYWNoIG9wZW4gdHJpYW5nbGUsIGNoZWNrIHRvIHNlZSBpZiB0aGUgY3VycmVudCBwb2ludCBpc1xuICAgICAgICAgKiBpbnNpZGUgaXQncyBjaXJjdW1jaXJjbGUuIElmIGl0IGlzLCByZW1vdmUgdGhlIHRyaWFuZ2xlIGFuZCBhZGRcbiAgICAgICAgICogaXQncyBlZGdlcyB0byBhbiBlZGdlIGxpc3QuICovXG4gICAgICAgIGZvcihqID0gb3Blbi5sZW5ndGg7IGotLTsgKSB7XG4gICAgICAgICAgLyogSWYgdGhpcyBwb2ludCBpcyB0byB0aGUgcmlnaHQgb2YgdGhpcyB0cmlhbmdsZSdzIGNpcmN1bWNpcmNsZSxcbiAgICAgICAgICAgKiB0aGVuIHRoaXMgdHJpYW5nbGUgc2hvdWxkIG5ldmVyIGdldCBjaGVja2VkIGFnYWluLiBSZW1vdmUgaXRcbiAgICAgICAgICAgKiBmcm9tIHRoZSBvcGVuIGxpc3QsIGFkZCBpdCB0byB0aGUgY2xvc2VkIGxpc3QsIGFuZCBza2lwLiAqL1xuICAgICAgICAgIGR4ID0gdmVydGljZXNbY11bMF0gLSBvcGVuW2pdLng7XG4gICAgICAgICAgaWYoZHggPiAwLjAgJiYgZHggKiBkeCA+IG9wZW5bal0ucikge1xuICAgICAgICAgICAgY2xvc2VkLnB1c2gob3BlbltqXSk7XG4gICAgICAgICAgICBvcGVuLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qIElmIHdlJ3JlIG91dHNpZGUgdGhlIGNpcmN1bWNpcmNsZSwgc2tpcCB0aGlzIHRyaWFuZ2xlLiAqL1xuICAgICAgICAgIGR5ID0gdmVydGljZXNbY11bMV0gLSBvcGVuW2pdLnk7XG4gICAgICAgICAgaWYoZHggKiBkeCArIGR5ICogZHkgLSBvcGVuW2pdLnIgPiBFUFNJTE9OKVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAvKiBSZW1vdmUgdGhlIHRyaWFuZ2xlIGFuZCBhZGQgaXQncyBlZGdlcyB0byB0aGUgZWRnZSBsaXN0LiAqL1xuICAgICAgICAgIGVkZ2VzLnB1c2goXG4gICAgICAgICAgICBvcGVuW2pdLmksIG9wZW5bal0uaixcbiAgICAgICAgICAgIG9wZW5bal0uaiwgb3BlbltqXS5rLFxuICAgICAgICAgICAgb3BlbltqXS5rLCBvcGVuW2pdLmlcbiAgICAgICAgICApO1xuICAgICAgICAgIG9wZW4uc3BsaWNlKGosIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogUmVtb3ZlIGFueSBkb3VibGVkIGVkZ2VzLiAqL1xuICAgICAgICBkZWR1cChlZGdlcyk7XG5cbiAgICAgICAgLyogQWRkIGEgbmV3IHRyaWFuZ2xlIGZvciBlYWNoIGVkZ2UuICovXG4gICAgICAgIGZvcihqID0gZWRnZXMubGVuZ3RoOyBqOyApIHtcbiAgICAgICAgICBiID0gZWRnZXNbLS1qXTtcbiAgICAgICAgICBhID0gZWRnZXNbLS1qXTtcbiAgICAgICAgICBvcGVuLnB1c2goY2lyY3VtY2lyY2xlKHZlcnRpY2VzLCBhLCBiLCBjKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyogQ29weSBhbnkgcmVtYWluaW5nIG9wZW4gdHJpYW5nbGVzIHRvIHRoZSBjbG9zZWQgbGlzdCwgYW5kIHRoZW5cbiAgICAgICAqIHJlbW92ZSBhbnkgdHJpYW5nbGVzIHRoYXQgc2hhcmUgYSB2ZXJ0ZXggd2l0aCB0aGUgc3VwZXJ0cmlhbmdsZSxcbiAgICAgICAqIGJ1aWxkaW5nIGEgbGlzdCBvZiB0cmlwbGV0cyB0aGF0IHJlcHJlc2VudCB0cmlhbmdsZXMuICovXG4gICAgICBmb3IoaSA9IG9wZW4ubGVuZ3RoOyBpLS07IClcbiAgICAgICAgY2xvc2VkLnB1c2gob3BlbltpXSk7XG4gICAgICBvcGVuLmxlbmd0aCA9IDA7XG5cbiAgICAgIGZvcihpID0gY2xvc2VkLmxlbmd0aDsgaS0tOyApXG4gICAgICAgIGlmKGNsb3NlZFtpXS5pIDwgbiAmJiBjbG9zZWRbaV0uaiA8IG4gJiYgY2xvc2VkW2ldLmsgPCBuKVxuICAgICAgICAgIG9wZW4ucHVzaChjbG9zZWRbaV0uaSwgY2xvc2VkW2ldLmosIGNsb3NlZFtpXS5rKTtcblxuICAgICAgLyogWWF5LCB3ZSdyZSBkb25lISAqL1xuICAgICAgcmV0dXJuIG9wZW47XG4gICAgfSxcbiAgICBjb250YWluczogZnVuY3Rpb24odHJpLCBwKSB7XG4gICAgICAvKiBCb3VuZGluZyBib3ggdGVzdCBmaXJzdCwgZm9yIHF1aWNrIHJlamVjdGlvbnMuICovXG4gICAgICBpZigocFswXSA8IHRyaVswXVswXSAmJiBwWzBdIDwgdHJpWzFdWzBdICYmIHBbMF0gPCB0cmlbMl1bMF0pIHx8XG4gICAgICAgICAocFswXSA+IHRyaVswXVswXSAmJiBwWzBdID4gdHJpWzFdWzBdICYmIHBbMF0gPiB0cmlbMl1bMF0pIHx8XG4gICAgICAgICAocFsxXSA8IHRyaVswXVsxXSAmJiBwWzFdIDwgdHJpWzFdWzFdICYmIHBbMV0gPCB0cmlbMl1bMV0pIHx8XG4gICAgICAgICAocFsxXSA+IHRyaVswXVsxXSAmJiBwWzFdID4gdHJpWzFdWzFdICYmIHBbMV0gPiB0cmlbMl1bMV0pKVxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgdmFyIGEgPSB0cmlbMV1bMF0gLSB0cmlbMF1bMF0sXG4gICAgICAgICAgYiA9IHRyaVsyXVswXSAtIHRyaVswXVswXSxcbiAgICAgICAgICBjID0gdHJpWzFdWzFdIC0gdHJpWzBdWzFdLFxuICAgICAgICAgIGQgPSB0cmlbMl1bMV0gLSB0cmlbMF1bMV0sXG4gICAgICAgICAgaSA9IGEgKiBkIC0gYiAqIGM7XG5cbiAgICAgIC8qIERlZ2VuZXJhdGUgdHJpLiAqL1xuICAgICAgaWYoaSA9PT0gMC4wKVxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgdmFyIHUgPSAoZCAqIChwWzBdIC0gdHJpWzBdWzBdKSAtIGIgKiAocFsxXSAtIHRyaVswXVsxXSkpIC8gaSxcbiAgICAgICAgICB2ID0gKGEgKiAocFsxXSAtIHRyaVswXVsxXSkgLSBjICogKHBbMF0gLSB0cmlbMF1bMF0pKSAvIGk7XG5cbiAgICAgIC8qIElmIHdlJ3JlIG91dHNpZGUgdGhlIHRyaSwgZmFpbC4gKi9cbiAgICAgIGlmKHUgPCAwLjAgfHwgdiA8IDAuMCB8fCAodSArIHYpID4gMS4wKVxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgcmV0dXJuIFt1LCB2XTtcbiAgICB9XG4gIH07XG5cbiAgaWYodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICBtb2R1bGUuZXhwb3J0cyA9IERlbGF1bmF5O1xufSkoKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/delaunay-fast/delaunay.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/background.js":
/*!***************************!*\
  !*** ./src/background.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("/**\n * Stars\n * Inspired by Steve Courtney's poster art for Celsius GS's Drifter - http://celsiusgs.com/drifter/posters.php\n * by Cory Hughart - http://coryhughart.com\n */ // Settings\nvar particleCount = 40, flareCount = 10, motion = 0.05, tilt = 0.05, color = '#FFEED4', particleSizeBase = 1, particleSizeMultiplier = 0.5, flareSizeBase = 100, flareSizeMultiplier = 100, lineWidth = 1, linkChance = 75, linkLengthMin = 5, linkLengthMax = 7, linkOpacity = 0.25; // number between 0 & 1\nlinkFade = 90, linkSpeed = 1, glareAngle = -60, glareOpacityMultiplier = 0.05, renderParticles = true, renderParticleGlare = true, renderFlares = true, renderLinks = true, renderMesh = false, flicker = true, flickerSmoothing = 15, blurSize = 0, orbitTilt = true, randomMotion = true, noiseLength = 1000, noiseStrength = 1;\nvar canvas = document.getElementById('stars'), //orbits = document.getElementById('orbits'),\ncontext = canvas.getContext('2d'), mouse = {\n    x: 0,\n    y: 0\n}, m = {}, r = 0, c = 1000, n = 0, nAngle = Math.PI * 2 / noiseLength, nRad = 100, nScale = 0.5, nPos = {\n    x: 0,\n    y: 0\n}, points = [], vertices = [], triangles = [], links = [], particles = [], flares = [];\nfunction init() {\n    var i, j, k;\n    // requestAnimFrame polyfill\n    window.requestAnimFrame = function() {\n        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {\n            window.setTimeout(callback, 1000 / 60);\n        };\n    }();\n    // Fade in background\n    /*\n    var background = document.getElementById('background'),\n      bgImg = new Image(),\n      bgURL = '/img/background.jpg';\n    bgImg.onload = function() {\n      //console.log('background loaded');\n      background.style.backgroundImage = 'url(\"'+bgURL+'\")';\n      background.className += ' loaded';\n    }\n    bgImg.src = bgURL;\n    */ // Size canvas\n    resize();\n    mouse.x = canvas.clientWidth / 2;\n    mouse.y = canvas.clientHeight / 2;\n    // Create particle positions\n    for(i = 0; i < particleCount; i++){\n        var p = new Particle();\n        particles.push(p);\n        points.push([\n            p.x * c,\n            p.y * c\n        ]);\n    }\n    //console.log(JSON.stringify(points));\n    // Delaunay triangulation\n    var Delaunay = __webpack_require__(/*! delaunay-fast */ \"(pages-dir-browser)/./node_modules/delaunay-fast/delaunay.js\");\n    vertices = Delaunay.triangulate(points);\n    //console.log(JSON.stringify(vertices));\n    // Create an array of \"triangles\" (groups of 3 indices)\n    var tri = [];\n    for(i = 0; i < vertices.length; i++){\n        if (tri.length == 3) {\n            triangles.push(tri);\n            tri = [];\n        }\n        tri.push(vertices[i]);\n    }\n    //console.log(JSON.stringify(triangles));\n    // Tell all the particles who their neighbors are\n    for(i = 0; i < particles.length; i++){\n        // Loop through all tirangles\n        for(j = 0; j < triangles.length; j++){\n            // Check if this particle's index is in this triangle\n            k = triangles[j].indexOf(i);\n            // If it is, add its neighbors to the particles contacts list\n            if (k !== -1) {\n                triangles[j].forEach(function(value, index, array) {\n                    if (value !== i && particles[i].neighbors.indexOf(value) == -1) {\n                        particles[i].neighbors.push(value);\n                    }\n                });\n            }\n        }\n    }\n    //console.log(JSON.stringify(particles));\n    if (renderFlares) {\n        // Create flare positions\n        for(i = 0; i < flareCount; i++){\n            flares.push(new Flare());\n        }\n    }\n    // Motion mode\n    //if (Modernizr && Modernizr.deviceorientation) {\n    if ('ontouchstart' in document.documentElement && window.DeviceOrientationEvent) {\n        console.log('Using device orientation');\n        window.addEventListener('deviceorientation', function(e) {\n            mouse.x = canvas.clientWidth / 2 - e.gamma / 90 * (canvas.clientWidth / 2) * 2;\n            mouse.y = canvas.clientHeight / 2 - e.beta / 90 * (canvas.clientHeight / 2) * 2;\n        //console.log('Center: x:'+(canvas.clientWidth/2)+' y:'+(canvas.clientHeight/2));\n        //console.log('Orientation: x:'+mouse.x+' ('+e.gamma+') y:'+mouse.y+' ('+e.beta+')');\n        }, true);\n    } else {\n        // Mouse move listener\n        console.log('Using mouse movement');\n        document.body.addEventListener('mousemove', function(e) {\n            //console.log('moved');\n            mouse.x = e.clientX;\n            mouse.y = e.clientY;\n        });\n    }\n    // Random motion\n    if (randomMotion) {\n    //var SimplexNoise = require('simplex-noise');\n    //var simplex = new SimplexNoise();\n    }\n    // Animation loop\n    (function animloop() {\n        requestAnimFrame(animloop);\n        resize();\n        render();\n    })();\n}\nfunction render() {\n    if (randomMotion) {\n        n++;\n        if (n >= noiseLength) {\n            n = 0;\n        }\n        nPos = noisePoint(n);\n    //console.log('NOISE x:'+nPos.x+' y:'+nPos.y);\n    }\n    // Clear\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    if (blurSize > 0) {\n        context.shadowBlur = blurSize;\n        context.shadowColor = color;\n    }\n    if (renderParticles) {\n        // Render particles\n        for(var i = 0; i < particleCount; i++){\n            particles[i].render();\n        }\n    }\n    if (renderMesh) {\n        // Render all lines\n        context.beginPath();\n        for(var v = 0; v < vertices.length - 1; v++){\n            // Splits the array into triplets\n            if ((v + 1) % 3 === 0) {\n                continue;\n            }\n            var p1 = particles[vertices[v]], p2 = particles[vertices[v + 1]];\n            //console.log('Line: '+p1.x+','+p1.y+'->'+p2.x+','+p2.y);\n            var pos1 = position(p1.x, p1.y, p1.z), pos2 = position(p2.x, p2.y, p2.z);\n            context.moveTo(pos1.x, pos1.y);\n            context.lineTo(pos2.x, pos2.y);\n        }\n        context.strokeStyle = color;\n        context.lineWidth = lineWidth;\n        context.stroke();\n        context.closePath();\n    }\n    if (renderLinks) {\n        // Possibly start a new link\n        if (random(0, linkChance) == linkChance) {\n            var length = random(linkLengthMin, linkLengthMax);\n            var start = random(0, particles.length - 1);\n            startLink(start, length);\n        }\n        // Render existing links\n        // Iterate in reverse so that removing items doesn't affect the loop\n        for(var l = links.length - 1; l >= 0; l--){\n            if (links[l] && !links[l].finished) {\n                links[l].render();\n            } else {\n                delete links[l];\n            }\n        }\n    }\n    if (renderFlares) {\n        // Render flares\n        for(var j = 0; j < flareCount; j++){\n            flares[j].render();\n        }\n    }\n/*\n    if (orbitTilt) {\n      var tiltX = -(((canvas.clientWidth / 2) - mouse.x + ((nPos.x - 0.5) * noiseStrength)) * tilt),\n        tiltY = (((canvas.clientHeight / 2) - mouse.y + ((nPos.y - 0.5) * noiseStrength)) * tilt);\n\n      orbits.style.transform = 'rotateY('+tiltX+'deg) rotateX('+tiltY+'deg)';\n    }\n    */ }\nfunction resize() {\n    canvas.width = window.innerWidth * (window.devicePixelRatio || 1);\n    canvas.height = canvas.width * (canvas.clientHeight / canvas.clientWidth);\n}\nfunction startLink(vertex, length) {\n    //console.log('LINK from '+vertex+' (length '+length+')');\n    links.push(new Link(vertex, length));\n}\n// Particle class\nvar Particle = function() {\n    this.x = random(-0.1, 1.1, true);\n    this.y = random(-0.1, 1.1, true);\n    this.z = random(0, 4);\n    this.color = color;\n    this.opacity = random(0.1, 1, true);\n    this.flicker = 0;\n    this.neighbors = []; // placeholder for neighbors\n};\n_c = Particle;\nParticle.prototype.render = function() {\n    var pos = position(this.x, this.y, this.z), r = (this.z * particleSizeMultiplier + particleSizeBase) * (sizeRatio() / 1000), o = this.opacity;\n    if (flicker) {\n        var newVal = random(-0.5, 0.5, true);\n        this.flicker += (newVal - this.flicker) / flickerSmoothing;\n        if (this.flicker > 0.5) this.flicker = 0.5;\n        if (this.flicker < -0.5) this.flicker = -0.5;\n        o += this.flicker;\n        if (o > 1) o = 1;\n        if (o < 0) o = 0;\n    }\n    context.fillStyle = this.color;\n    context.globalAlpha = o;\n    context.beginPath();\n    context.arc(pos.x, pos.y, r, 0, 2 * Math.PI, false);\n    context.fill();\n    context.closePath();\n    if (renderParticleGlare) {\n        context.globalAlpha = o * glareOpacityMultiplier;\n        /*\n        context.ellipse(pos.x, pos.y, r * 30, r, 90 * (Math.PI / 180), 0, 2 * Math.PI, false);\n        context.fill();\n        context.closePath();\n        */ context.ellipse(pos.x, pos.y, r * 100, r, (glareAngle - (nPos.x - 0.5) * noiseStrength * motion) * (Math.PI / 180), 0, 2 * Math.PI, false);\n        context.fill();\n        context.closePath();\n    }\n    context.globalAlpha = 1;\n};\n// Flare class\nvar Flare = function() {\n    this.x = random(-0.25, 1.25, true);\n    this.y = random(-0.25, 1.25, true);\n    this.z = random(0, 2);\n    this.color = color;\n    this.opacity = random(0.001, 0.01, true);\n};\n_c1 = Flare;\nFlare.prototype.render = function() {\n    var pos = position(this.x, this.y, this.z), r = (this.z * flareSizeMultiplier + flareSizeBase) * (sizeRatio() / 1000);\n    // Feathered circles\n    /*\n    var grad = context.createRadialGradient(x+r,y+r,0,x+r,y+r,r);\n    grad.addColorStop(0, 'rgba(255,255,255,'+f.o+')');\n    grad.addColorStop(0.8, 'rgba(255,255,255,'+f.o+')');\n    grad.addColorStop(1, 'rgba(255,255,255,0)');\n    context.fillStyle = grad;\n    context.beginPath();\n    context.fillRect(x, y, r*2, r*2);\n    context.closePath();\n    */ context.beginPath();\n    context.globalAlpha = this.opacity;\n    context.arc(pos.x, pos.y, r, 0, 2 * Math.PI, false);\n    context.fillStyle = this.color;\n    context.fill();\n    context.closePath();\n    context.globalAlpha = 1;\n};\n// Link class\nvar Link = function(startVertex, numPoints) {\n    this.length = numPoints;\n    this.verts = [\n        startVertex\n    ];\n    this.stage = 0;\n    this.linked = [\n        startVertex\n    ];\n    this.distances = [];\n    this.traveled = 0;\n    this.fade = 0;\n    this.finished = false;\n};\n_c2 = Link;\nLink.prototype.render = function() {\n    // Stages:\n    // 0. Vertex collection\n    // 1. Render line reaching from vertex to vertex\n    // 2. Fade out\n    // 3. Finished (delete me)\n    var i, p, pos, points;\n    switch(this.stage){\n        // VERTEX COLLECTION STAGE\n        case 0:\n            // Grab the last member of the link\n            var last = particles[this.verts[this.verts.length - 1]];\n            //console.log(JSON.stringify(last));\n            if (last && last.neighbors && last.neighbors.length > 0) {\n                // Grab a random neighbor\n                var neighbor = last.neighbors[random(0, last.neighbors.length - 1)];\n                // If we haven't seen that particle before, add it to the link\n                if (this.verts.indexOf(neighbor) == -1) {\n                    this.verts.push(neighbor);\n                }\n            // If we have seen that particle before, we'll just wait for the next frame\n            } else {\n                //console.log(this.verts[0]+' prematurely moving to stage 3 (0)');\n                this.stage = 3;\n                this.finished = true;\n            }\n            if (this.verts.length >= this.length) {\n                // Calculate all distances at once\n                for(i = 0; i < this.verts.length - 1; i++){\n                    var p1 = particles[this.verts[i]], p2 = particles[this.verts[i + 1]], dx = p1.x - p2.x, dy = p1.y - p2.y, dist = Math.sqrt(dx * dx + dy * dy);\n                    this.distances.push(dist);\n                }\n                //console.log('Distances: '+JSON.stringify(this.distances));\n                //console.log('verts: '+this.verts.length+' distances: '+this.distances.length);\n                //console.log(this.verts[0]+' moving to stage 1');\n                this.stage = 1;\n            }\n            break;\n        // RENDER LINE ANIMATION STAGE\n        case 1:\n            if (this.distances.length > 0) {\n                points = [];\n                //var a = 1;\n                // Gather all points already linked\n                for(i = 0; i < this.linked.length; i++){\n                    p = particles[this.linked[i]];\n                    pos = position(p.x, p.y, p.z);\n                    points.push([\n                        pos.x,\n                        pos.y\n                    ]);\n                }\n                var linkSpeedRel = linkSpeed * 0.00001 * canvas.width;\n                this.traveled += linkSpeedRel;\n                var d = this.distances[this.linked.length - 1];\n                // Calculate last point based on linkSpeed and distance travelled to next point\n                if (this.traveled >= d) {\n                    this.traveled = 0;\n                    // We've reached the next point, add coordinates to array\n                    //console.log(this.verts[0]+' reached vertex '+(this.linked.length+1)+' of '+this.verts.length);\n                    this.linked.push(this.verts[this.linked.length]);\n                    p = particles[this.linked[this.linked.length - 1]];\n                    pos = position(p.x, p.y, p.z);\n                    points.push([\n                        pos.x,\n                        pos.y\n                    ]);\n                    if (this.linked.length >= this.verts.length) {\n                        //console.log(this.verts[0]+' moving to stage 2 (1)');\n                        this.stage = 2;\n                    }\n                } else {\n                    // We're still travelling to the next point, get coordinates at travel distance\n                    // http://math.stackexchange.com/a/85582\n                    var a = particles[this.linked[this.linked.length - 1]], b = particles[this.verts[this.linked.length]], t = d - this.traveled, x = (this.traveled * b.x + t * a.x) / d, y = (this.traveled * b.y + t * a.y) / d, z = (this.traveled * b.z + t * a.z) / d;\n                    pos = position(x, y, z);\n                    //console.log(this.verts[0]+' traveling to vertex '+(this.linked.length+1)+' of '+this.verts.length+' ('+this.traveled+' of '+this.distances[this.linked.length]+')');\n                    points.push([\n                        pos.x,\n                        pos.y\n                    ]);\n                }\n                this.drawLine(points);\n            } else {\n                //console.log(this.verts[0]+' prematurely moving to stage 3 (1)');\n                this.stage = 3;\n                this.finished = true;\n            }\n            break;\n        // FADE OUT STAGE\n        case 2:\n            if (this.verts.length > 1) {\n                if (this.fade < linkFade) {\n                    this.fade++;\n                    // Render full link between all vertices and fade over time\n                    points = [];\n                    var alpha = (1 - this.fade / linkFade) * linkOpacity;\n                    for(i = 0; i < this.verts.length; i++){\n                        p = particles[this.verts[i]];\n                        pos = position(p.x, p.y, p.z);\n                        points.push([\n                            pos.x,\n                            pos.y\n                        ]);\n                    }\n                    this.drawLine(points, alpha);\n                } else {\n                    //console.log(this.verts[0]+' moving to stage 3 (2a)');\n                    this.stage = 3;\n                    this.finished = true;\n                }\n            } else {\n                //console.log(this.verts[0]+' prematurely moving to stage 3 (2b)');\n                this.stage = 3;\n                this.finished = true;\n            }\n            break;\n        // FINISHED STAGE\n        case 3:\n        default:\n            this.finished = true;\n            break;\n    }\n};\nLink.prototype.drawLine = function(points, alpha) {\n    if (typeof alpha !== 'number') alpha = linkOpacity;\n    if (points.length > 1 && alpha > 0) {\n        //console.log(this.verts[0]+': Drawing line '+alpha);\n        context.globalAlpha = alpha;\n        context.beginPath();\n        for(var i = 0; i < points.length - 1; i++){\n            context.moveTo(points[i][0], points[i][1]);\n            context.lineTo(points[i + 1][0], points[i + 1][1]);\n        }\n        context.strokeStyle = color;\n        context.lineWidth = lineWidth;\n        context.stroke();\n        context.closePath();\n        context.globalAlpha = 1;\n    }\n};\n// Utils\nfunction noisePoint(i) {\n    var a = nAngle * i, cosA = Math.cos(a), sinA = Math.sin(a), //value = simplex.noise2D(nScale * cosA + nScale, nScale * sinA + nScale),\n    //rad = nRad + value;\n    rad = nRad;\n    return {\n        x: rad * cosA,\n        y: rad * sinA\n    };\n}\nfunction position(x, y, z) {\n    return {\n        x: x * canvas.width + (canvas.width / 2 - mouse.x + (nPos.x - 0.5) * noiseStrength) * z * motion,\n        y: y * canvas.height + (canvas.height / 2 - mouse.y + (nPos.y - 0.5) * noiseStrength) * z * motion\n    };\n}\nfunction sizeRatio() {\n    return canvas.width >= canvas.height ? canvas.width : canvas.height;\n}\nfunction random(min, max, float) {\n    return float ? Math.random() * (max - min) + min : Math.floor(Math.random() * (max - min + 1)) + min;\n}\n// init\nif (canvas) init();\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"Particle\");\n$RefreshReg$(_c1, \"Flare\");\n$RefreshReg$(_c2, \"Link\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9iYWNrZ3JvdW5kLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7O0NBSUMsR0FFRCxXQUFXO0FBQ1gsSUFBSUEsZ0JBQWdCLElBQ2hCQyxhQUFhLElBQ2JDLFNBQVMsTUFDVEMsT0FBTyxNQUNQQyxRQUFRLFdBQ1JDLG1CQUFtQixHQUNuQkMseUJBQXlCLEtBQ3pCQyxnQkFBZ0IsS0FDaEJDLHNCQUFzQixLQUN0QkMsWUFBWSxHQUNaQyxhQUFhLElBQ2JDLGdCQUFnQixHQUNoQkMsZ0JBQWdCLEdBQ2hCQyxjQUFjLE1BQU0sdUJBQXVCO0FBQzNDQyxXQUFXLElBQ1hDLFlBQVksR0FDWkMsYUFBYSxDQUFDLElBQ2RDLHlCQUF5QixNQUN6QkMsa0JBQWtCLE1BQ2xCQyxzQkFBc0IsTUFDdEJDLGVBQWUsTUFDZkMsY0FBYyxNQUNkQyxhQUFhLE9BQ2JDLFVBQVUsTUFDVkMsbUJBQW1CLElBQ25CQyxXQUFXLEdBQ1hDLFlBQVksTUFDWkMsZUFBZSxNQUNmQyxjQUFjLE1BQ2RDLGdCQUFnQjtBQUVwQixJQUFJQyxTQUFTQyxTQUFTQyxjQUFjLENBQUMsVUFDakMsNkNBQTZDO0FBQzdDQyxVQUFVSCxPQUFPSSxVQUFVLENBQUMsT0FDNUJDLFFBQVE7SUFBQ0MsR0FBRztJQUFHQyxHQUFHO0FBQUMsR0FDbkJDLElBQUksQ0FBQyxHQUNMQyxJQUFJLEdBQ0pDLElBQUksTUFDSkMsSUFBSSxHQUNKQyxTQUFTLEtBQU1FLEVBQUUsR0FBRyxJQUFLaEIsYUFDekJpQixPQUFPLEtBQ1BDLFNBQVMsS0FDVEMsT0FBTztJQUFDWCxHQUFHO0lBQUdDLEdBQUc7QUFBQyxHQUNsQlcsU0FBUyxFQUFFLEVBQ1hDLFdBQVcsRUFBRSxFQUNiQyxZQUFZLEVBQUUsRUFDZEMsUUFBUSxFQUFFLEVBQ1ZDLFlBQVksRUFBRSxFQUNkQyxTQUFTLEVBQUU7QUFFZixTQUFTQztJQUNMLElBQUlDLEdBQUdDLEdBQUdDO0lBRVYsNEJBQTRCO0lBQzVCQyxPQUFP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S3dFLE1BQU0sS0FBTStDLENBQUFBLE1BQU1ELEdBQUUsSUFBS0EsTUFDOUJ0SCxLQUFLeUgsS0FBSyxDQUFDekgsS0FBS3dFLE1BQU0sS0FBTStDLENBQUFBLE1BQU1ELE1BQU0sTUFBTUE7QUFDdEQ7QUFHQSxPQUFPO0FBQ1AsSUFBSW5JLFFBQVF3QiIsInNvdXJjZXMiOlsiL1VzZXJzL2ljZXNwaWNlL1Nwb3RNb29kXy9zcmMvYmFja2dyb3VuZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFN0YXJzXG4gKiBJbnNwaXJlZCBieSBTdGV2ZSBDb3VydG5leSdzIHBvc3RlciBhcnQgZm9yIENlbHNpdXMgR1MncyBEcmlmdGVyIC0gaHR0cDovL2NlbHNpdXNncy5jb20vZHJpZnRlci9wb3N0ZXJzLnBocFxuICogYnkgQ29yeSBIdWdoYXJ0IC0gaHR0cDovL2NvcnlodWdoYXJ0LmNvbVxuICovXG5cbi8vIFNldHRpbmdzXG52YXIgcGFydGljbGVDb3VudCA9IDQwLFxuICAgIGZsYXJlQ291bnQgPSAxMCxcbiAgICBtb3Rpb24gPSAwLjA1LFxuICAgIHRpbHQgPSAwLjA1LFxuICAgIGNvbG9yID0gJyNGRkVFRDQnLFxuICAgIHBhcnRpY2xlU2l6ZUJhc2UgPSAxLFxuICAgIHBhcnRpY2xlU2l6ZU11bHRpcGxpZXIgPSAwLjUsXG4gICAgZmxhcmVTaXplQmFzZSA9IDEwMCxcbiAgICBmbGFyZVNpemVNdWx0aXBsaWVyID0gMTAwLFxuICAgIGxpbmVXaWR0aCA9IDEsXG4gICAgbGlua0NoYW5jZSA9IDc1LCAvLyBjaGFuY2UgcGVyIGZyYW1lIG9mIGxpbmssIGhpZ2hlciA9IHNtYWxsZXIgY2hhbmNlXG4gICAgbGlua0xlbmd0aE1pbiA9IDUsIC8vIG1pbiBsaW5rZWQgdmVydGljZXNcbiAgICBsaW5rTGVuZ3RoTWF4ID0gNywgLy8gbWF4IGxpbmtlZCB2ZXJ0aWNlc1xuICAgIGxpbmtPcGFjaXR5ID0gMC4yNTsgLy8gbnVtYmVyIGJldHdlZW4gMCAmIDFcbiAgICBsaW5rRmFkZSA9IDkwLCAvLyBsaW5rIGZhZGUtb3V0IGZyYW1lc1xuICAgIGxpbmtTcGVlZCA9IDEsIC8vIGRpc3RhbmNlIGEgbGluayB0cmF2ZWxzIGluIDEgZnJhbWVcbiAgICBnbGFyZUFuZ2xlID0gLTYwLFxuICAgIGdsYXJlT3BhY2l0eU11bHRpcGxpZXIgPSAwLjA1LFxuICAgIHJlbmRlclBhcnRpY2xlcyA9IHRydWUsXG4gICAgcmVuZGVyUGFydGljbGVHbGFyZSA9IHRydWUsXG4gICAgcmVuZGVyRmxhcmVzID0gdHJ1ZSxcbiAgICByZW5kZXJMaW5rcyA9IHRydWUsXG4gICAgcmVuZGVyTWVzaCA9IGZhbHNlLFxuICAgIGZsaWNrZXIgPSB0cnVlLFxuICAgIGZsaWNrZXJTbW9vdGhpbmcgPSAxNSwgLy8gaGlnaGVyID0gc21vb3RoZXIgZmxpY2tlclxuICAgIGJsdXJTaXplID0gMCxcbiAgICBvcmJpdFRpbHQgPSB0cnVlLFxuICAgIHJhbmRvbU1vdGlvbiA9IHRydWUsXG4gICAgbm9pc2VMZW5ndGggPSAxMDAwLFxuICAgIG5vaXNlU3RyZW5ndGggPSAxO1xuXG52YXIgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YXJzJyksXG4gICAgLy9vcmJpdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnb3JiaXRzJyksXG4gICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLFxuICAgIG1vdXNlID0ge3g6IDAsIHk6IDB9LFxuICAgIG0gPSB7fSxcbiAgICByID0gMCxcbiAgICBjID0gMTAwMCwgLy8gbXVsdGlwbGllciBmb3IgZGVsYXVuYXkgcG9pbnRzLCBzaW5jZSBmbG9hdHMgdG9vIHNtYWxsIGNhbiBtZXNzIHVwIHRoZSBhbGdvcml0aG1cbiAgICBuID0gMCxcbiAgICBuQW5nbGUgPSAoTWF0aC5QSSAqIDIpIC8gbm9pc2VMZW5ndGgsXG4gICAgblJhZCA9IDEwMCxcbiAgICBuU2NhbGUgPSAwLjUsXG4gICAgblBvcyA9IHt4OiAwLCB5OiAwfSxcbiAgICBwb2ludHMgPSBbXSxcbiAgICB2ZXJ0aWNlcyA9IFtdLFxuICAgIHRyaWFuZ2xlcyA9IFtdLFxuICAgIGxpbmtzID0gW10sXG4gICAgcGFydGljbGVzID0gW10sXG4gICAgZmxhcmVzID0gW107XG5cbmZ1bmN0aW9uIGluaXQoKSB7XG4gICAgdmFyIGksIGosIGs7XG5cbiAgICAvLyByZXF1ZXN0QW5pbUZyYW1lIHBvbHlmaWxsXG4gICAgd2luZG93LnJlcXVlc3RBbmltRnJhbWUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gICAgICAgICAgICB9O1xuICAgIH0pKCk7XG5cbiAgICAvLyBGYWRlIGluIGJhY2tncm91bmRcbiAgICAvKlxuICAgIHZhciBiYWNrZ3JvdW5kID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JhY2tncm91bmQnKSxcbiAgICAgIGJnSW1nID0gbmV3IEltYWdlKCksXG4gICAgICBiZ1VSTCA9ICcvaW1nL2JhY2tncm91bmQuanBnJztcbiAgICBiZ0ltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vY29uc29sZS5sb2coJ2JhY2tncm91bmQgbG9hZGVkJyk7XG4gICAgICBiYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9ICd1cmwoXCInK2JnVVJMKydcIiknO1xuICAgICAgYmFja2dyb3VuZC5jbGFzc05hbWUgKz0gJyBsb2FkZWQnO1xuICAgIH1cbiAgICBiZ0ltZy5zcmMgPSBiZ1VSTDtcbiAgICAqL1xuXG4gICAgLy8gU2l6ZSBjYW52YXNcbiAgICByZXNpemUoKTtcblxuICAgIG1vdXNlLnggPSBjYW52YXMuY2xpZW50V2lkdGggLyAyO1xuICAgIG1vdXNlLnkgPSBjYW52YXMuY2xpZW50SGVpZ2h0IC8gMjtcblxuICAgIC8vIENyZWF0ZSBwYXJ0aWNsZSBwb3NpdGlvbnNcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGFydGljbGVDb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciBwID0gbmV3IFBhcnRpY2xlKCk7XG4gICAgICAgIHBhcnRpY2xlcy5wdXNoKHApO1xuICAgICAgICBwb2ludHMucHVzaChbcC54ICogYywgcC55ICogY10pO1xuICAgIH1cblxuICAgIC8vY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkocG9pbnRzKSk7XG5cbiAgICAvLyBEZWxhdW5heSB0cmlhbmd1bGF0aW9uXG4gICAgdmFyIERlbGF1bmF5ID0gcmVxdWlyZSgnZGVsYXVuYXktZmFzdCcpO1xuICAgIHZlcnRpY2VzID0gRGVsYXVuYXkudHJpYW5ndWxhdGUocG9pbnRzKTtcbiAgICAvL2NvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KHZlcnRpY2VzKSk7XG4gICAgLy8gQ3JlYXRlIGFuIGFycmF5IG9mIFwidHJpYW5nbGVzXCIgKGdyb3VwcyBvZiAzIGluZGljZXMpXG4gICAgdmFyIHRyaSA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodHJpLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaCh0cmkpO1xuICAgICAgICAgICAgdHJpID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdHJpLnB1c2godmVydGljZXNbaV0pO1xuICAgIH1cbiAgICAvL2NvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KHRyaWFuZ2xlcykpO1xuXG4gICAgLy8gVGVsbCBhbGwgdGhlIHBhcnRpY2xlcyB3aG8gdGhlaXIgbmVpZ2hib3JzIGFyZVxuICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0aWNsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGFsbCB0aXJhbmdsZXNcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHRyaWFuZ2xlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBwYXJ0aWNsZSdzIGluZGV4IGlzIGluIHRoaXMgdHJpYW5nbGVcbiAgICAgICAgICAgIGsgPSB0cmlhbmdsZXNbal0uaW5kZXhPZihpKTtcbiAgICAgICAgICAgIC8vIElmIGl0IGlzLCBhZGQgaXRzIG5laWdoYm9ycyB0byB0aGUgcGFydGljbGVzIGNvbnRhY3RzIGxpc3RcbiAgICAgICAgICAgIGlmIChrICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRyaWFuZ2xlc1tqXS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gaSAmJiBwYXJ0aWNsZXNbaV0ubmVpZ2hib3JzLmluZGV4T2YodmFsdWUpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZXNbaV0ubmVpZ2hib3JzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy9jb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShwYXJ0aWNsZXMpKTtcblxuICAgIGlmIChyZW5kZXJGbGFyZXMpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGZsYXJlIHBvc2l0aW9uc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZmxhcmVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBmbGFyZXMucHVzaChuZXcgRmxhcmUoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNb3Rpb24gbW9kZVxuICAgIC8vaWYgKE1vZGVybml6ciAmJiBNb2Rlcm5penIuZGV2aWNlb3JpZW50YXRpb24pIHtcbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIHdpbmRvdy5EZXZpY2VPcmllbnRhdGlvbkV2ZW50KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdVc2luZyBkZXZpY2Ugb3JpZW50YXRpb24nKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZW9yaWVudGF0aW9uJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIG1vdXNlLnggPSAoY2FudmFzLmNsaWVudFdpZHRoIC8gMikgLSAoKGUuZ2FtbWEgLyA5MCkgKiAoY2FudmFzLmNsaWVudFdpZHRoIC8gMikgKiAyKTtcbiAgICAgICAgICAgIG1vdXNlLnkgPSAoY2FudmFzLmNsaWVudEhlaWdodCAvIDIpIC0gKChlLmJldGEgLyA5MCkgKiAoY2FudmFzLmNsaWVudEhlaWdodCAvIDIpICogMik7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdDZW50ZXI6IHg6JysoY2FudmFzLmNsaWVudFdpZHRoLzIpKycgeTonKyhjYW52YXMuY2xpZW50SGVpZ2h0LzIpKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ09yaWVudGF0aW9uOiB4OicrbW91c2UueCsnICgnK2UuZ2FtbWErJykgeTonK21vdXNlLnkrJyAoJytlLmJldGErJyknKTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTW91c2UgbW92ZSBsaXN0ZW5lclxuICAgICAgICBjb25zb2xlLmxvZygnVXNpbmcgbW91c2UgbW92ZW1lbnQnKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnbW92ZWQnKTtcbiAgICAgICAgICAgIG1vdXNlLnggPSBlLmNsaWVudFg7XG4gICAgICAgICAgICBtb3VzZS55ID0gZS5jbGllbnRZO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBSYW5kb20gbW90aW9uXG4gICAgaWYgKHJhbmRvbU1vdGlvbikge1xuICAgICAgICAvL3ZhciBTaW1wbGV4Tm9pc2UgPSByZXF1aXJlKCdzaW1wbGV4LW5vaXNlJyk7XG4gICAgICAgIC8vdmFyIHNpbXBsZXggPSBuZXcgU2ltcGxleE5vaXNlKCk7XG4gICAgfVxuXG4gICAgLy8gQW5pbWF0aW9uIGxvb3BcbiAgICAoZnVuY3Rpb24gYW5pbWxvb3AoKSB7XG4gICAgICAgIHJlcXVlc3RBbmltRnJhbWUoYW5pbWxvb3ApO1xuICAgICAgICByZXNpemUoKTtcbiAgICAgICAgcmVuZGVyKCk7XG4gICAgfSkoKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIGlmIChyYW5kb21Nb3Rpb24pIHtcbiAgICAgICAgbisrO1xuICAgICAgICBpZiAobiA+PSBub2lzZUxlbmd0aCkge1xuICAgICAgICAgICAgbiA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBuUG9zID0gbm9pc2VQb2ludChuKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnTk9JU0UgeDonK25Qb3MueCsnIHk6JytuUG9zLnkpO1xuICAgIH1cblxuICAgIC8vIENsZWFyXG4gICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgIGlmIChibHVyU2l6ZSA+IDApIHtcbiAgICAgICAgY29udGV4dC5zaGFkb3dCbHVyID0gYmx1clNpemU7XG4gICAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBjb2xvcjtcbiAgICB9XG5cbiAgICBpZiAocmVuZGVyUGFydGljbGVzKSB7XG4gICAgICAgIC8vIFJlbmRlciBwYXJ0aWNsZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0aWNsZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHBhcnRpY2xlc1tpXS5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZW5kZXJNZXNoKSB7XG4gICAgICAgIC8vIFJlbmRlciBhbGwgbGluZXNcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCB2ZXJ0aWNlcy5sZW5ndGggLSAxOyB2KyspIHtcbiAgICAgICAgICAgIC8vIFNwbGl0cyB0aGUgYXJyYXkgaW50byB0cmlwbGV0c1xuICAgICAgICAgICAgaWYgKCh2ICsgMSkgJSAzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwMSA9IHBhcnRpY2xlc1t2ZXJ0aWNlc1t2XV0sXG4gICAgICAgICAgICAgICAgcDIgPSBwYXJ0aWNsZXNbdmVydGljZXNbdiArIDFdXTtcblxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnTGluZTogJytwMS54KycsJytwMS55KyctPicrcDIueCsnLCcrcDIueSk7XG5cbiAgICAgICAgICAgIHZhciBwb3MxID0gcG9zaXRpb24ocDEueCwgcDEueSwgcDEueiksXG4gICAgICAgICAgICAgICAgcG9zMiA9IHBvc2l0aW9uKHAyLngsIHAyLnksIHAyLnopO1xuXG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhwb3MxLngsIHBvczEueSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwb3MyLngsIHBvczIueSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG5cbiAgICBpZiAocmVuZGVyTGlua3MpIHtcbiAgICAgICAgLy8gUG9zc2libHkgc3RhcnQgYSBuZXcgbGlua1xuICAgICAgICBpZiAocmFuZG9tKDAsIGxpbmtDaGFuY2UpID09IGxpbmtDaGFuY2UpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSByYW5kb20obGlua0xlbmd0aE1pbiwgbGlua0xlbmd0aE1heCk7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSByYW5kb20oMCwgcGFydGljbGVzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgc3RhcnRMaW5rKHN0YXJ0LCBsZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVuZGVyIGV4aXN0aW5nIGxpbmtzXG4gICAgICAgIC8vIEl0ZXJhdGUgaW4gcmV2ZXJzZSBzbyB0aGF0IHJlbW92aW5nIGl0ZW1zIGRvZXNuJ3QgYWZmZWN0IHRoZSBsb29wXG4gICAgICAgIGZvciAodmFyIGwgPSBsaW5rcy5sZW5ndGggLSAxOyBsID49IDA7IGwtLSkge1xuICAgICAgICAgICAgaWYgKGxpbmtzW2xdICYmICFsaW5rc1tsXS5maW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIGxpbmtzW2xdLnJlbmRlcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbGlua3NbbF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVuZGVyRmxhcmVzKSB7XG4gICAgICAgIC8vIFJlbmRlciBmbGFyZXNcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmbGFyZUNvdW50OyBqKyspIHtcbiAgICAgICAgICAgIGZsYXJlc1tqXS5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgaWYgKG9yYml0VGlsdCkge1xuICAgICAgdmFyIHRpbHRYID0gLSgoKGNhbnZhcy5jbGllbnRXaWR0aCAvIDIpIC0gbW91c2UueCArICgoblBvcy54IC0gMC41KSAqIG5vaXNlU3RyZW5ndGgpKSAqIHRpbHQpLFxuICAgICAgICB0aWx0WSA9ICgoKGNhbnZhcy5jbGllbnRIZWlnaHQgLyAyKSAtIG1vdXNlLnkgKyAoKG5Qb3MueSAtIDAuNSkgKiBub2lzZVN0cmVuZ3RoKSkgKiB0aWx0KTtcblxuICAgICAgb3JiaXRzLnN0eWxlLnRyYW5zZm9ybSA9ICdyb3RhdGVZKCcrdGlsdFgrJ2RlZykgcm90YXRlWCgnK3RpbHRZKydkZWcpJztcbiAgICB9XG4gICAgKi9cbn1cblxuZnVuY3Rpb24gcmVzaXplKCkge1xuICAgIGNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoICogKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMud2lkdGggKiAoY2FudmFzLmNsaWVudEhlaWdodCAvIGNhbnZhcy5jbGllbnRXaWR0aCk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0TGluayh2ZXJ0ZXgsIGxlbmd0aCkge1xuICAgIC8vY29uc29sZS5sb2coJ0xJTksgZnJvbSAnK3ZlcnRleCsnIChsZW5ndGggJytsZW5ndGgrJyknKTtcbiAgICBsaW5rcy5wdXNoKG5ldyBMaW5rKHZlcnRleCwgbGVuZ3RoKSk7XG59XG5cbi8vIFBhcnRpY2xlIGNsYXNzXG52YXIgUGFydGljbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy54ID0gcmFuZG9tKC0wLjEsIDEuMSwgdHJ1ZSk7XG4gICAgdGhpcy55ID0gcmFuZG9tKC0wLjEsIDEuMSwgdHJ1ZSk7XG4gICAgdGhpcy56ID0gcmFuZG9tKDAsIDQpO1xuICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLm9wYWNpdHkgPSByYW5kb20oMC4xLCAxLCB0cnVlKTtcbiAgICB0aGlzLmZsaWNrZXIgPSAwO1xuICAgIHRoaXMubmVpZ2hib3JzID0gW107IC8vIHBsYWNlaG9sZGVyIGZvciBuZWlnaGJvcnNcbn07XG5QYXJ0aWNsZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwb3MgPSBwb3NpdGlvbih0aGlzLngsIHRoaXMueSwgdGhpcy56KSxcbiAgICAgICAgciA9ICgodGhpcy56ICogcGFydGljbGVTaXplTXVsdGlwbGllcikgKyBwYXJ0aWNsZVNpemVCYXNlKSAqIChzaXplUmF0aW8oKSAvIDEwMDApLFxuICAgICAgICBvID0gdGhpcy5vcGFjaXR5O1xuXG4gICAgaWYgKGZsaWNrZXIpIHtcbiAgICAgICAgdmFyIG5ld1ZhbCA9IHJhbmRvbSgtMC41LCAwLjUsIHRydWUpO1xuICAgICAgICB0aGlzLmZsaWNrZXIgKz0gKG5ld1ZhbCAtIHRoaXMuZmxpY2tlcikgLyBmbGlja2VyU21vb3RoaW5nO1xuICAgICAgICBpZiAodGhpcy5mbGlja2VyID4gMC41KSB0aGlzLmZsaWNrZXIgPSAwLjU7XG4gICAgICAgIGlmICh0aGlzLmZsaWNrZXIgPCAtMC41KSB0aGlzLmZsaWNrZXIgPSAtMC41O1xuICAgICAgICBvICs9IHRoaXMuZmxpY2tlcjtcbiAgICAgICAgaWYgKG8gPiAxKSBvID0gMTtcbiAgICAgICAgaWYgKG8gPCAwKSBvID0gMDtcbiAgICB9XG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IG87XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0LmFyYyhwb3MueCwgcG9zLnksIHIsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgY29udGV4dC5maWxsKCk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgIGlmIChyZW5kZXJQYXJ0aWNsZUdsYXJlKSB7XG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBvICogZ2xhcmVPcGFjaXR5TXVsdGlwbGllcjtcbiAgICAgICAgLypcbiAgICAgICAgY29udGV4dC5lbGxpcHNlKHBvcy54LCBwb3MueSwgciAqIDMwLCByLCA5MCAqIChNYXRoLlBJIC8gMTgwKSwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICovXG4gICAgICAgIGNvbnRleHQuZWxsaXBzZShwb3MueCwgcG9zLnksIHIgKiAxMDAsIHIsIChnbGFyZUFuZ2xlIC0gKChuUG9zLnggLSAwLjUpICogbm9pc2VTdHJlbmd0aCAqIG1vdGlvbikpICogKE1hdGguUEkgLyAxODApLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG5cbiAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gMTtcbn07XG5cbi8vIEZsYXJlIGNsYXNzXG52YXIgRmxhcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy54ID0gcmFuZG9tKC0wLjI1LCAxLjI1LCB0cnVlKTtcbiAgICB0aGlzLnkgPSByYW5kb20oLTAuMjUsIDEuMjUsIHRydWUpO1xuICAgIHRoaXMueiA9IHJhbmRvbSgwLCAyKTtcbiAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gICAgdGhpcy5vcGFjaXR5ID0gcmFuZG9tKDAuMDAxLCAwLjAxLCB0cnVlKTtcbn07XG5GbGFyZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwb3MgPSBwb3NpdGlvbih0aGlzLngsIHRoaXMueSwgdGhpcy56KSxcbiAgICAgICAgciA9ICgodGhpcy56ICogZmxhcmVTaXplTXVsdGlwbGllcikgKyBmbGFyZVNpemVCYXNlKSAqIChzaXplUmF0aW8oKSAvIDEwMDApO1xuXG4gICAgLy8gRmVhdGhlcmVkIGNpcmNsZXNcbiAgICAvKlxuICAgIHZhciBncmFkID0gY29udGV4dC5jcmVhdGVSYWRpYWxHcmFkaWVudCh4K3IseStyLDAseCtyLHkrcixyKTtcbiAgICBncmFkLmFkZENvbG9yU3RvcCgwLCAncmdiYSgyNTUsMjU1LDI1NSwnK2YubysnKScpO1xuICAgIGdyYWQuYWRkQ29sb3JTdG9wKDAuOCwgJ3JnYmEoMjU1LDI1NSwyNTUsJytmLm8rJyknKTtcbiAgICBncmFkLmFkZENvbG9yU3RvcCgxLCAncmdiYSgyNTUsMjU1LDI1NSwwKScpO1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gZ3JhZDtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQuZmlsbFJlY3QoeCwgeSwgcioyLCByKjIpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgKi9cblxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IHRoaXMub3BhY2l0eTtcbiAgICBjb250ZXh0LmFyYyhwb3MueCwgcG9zLnksIHIsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IDE7XG59O1xuXG4vLyBMaW5rIGNsYXNzXG52YXIgTGluayA9IGZ1bmN0aW9uIChzdGFydFZlcnRleCwgbnVtUG9pbnRzKSB7XG4gICAgdGhpcy5sZW5ndGggPSBudW1Qb2ludHM7XG4gICAgdGhpcy52ZXJ0cyA9IFtzdGFydFZlcnRleF07XG4gICAgdGhpcy5zdGFnZSA9IDA7XG4gICAgdGhpcy5saW5rZWQgPSBbc3RhcnRWZXJ0ZXhdO1xuICAgIHRoaXMuZGlzdGFuY2VzID0gW107XG4gICAgdGhpcy50cmF2ZWxlZCA9IDA7XG4gICAgdGhpcy5mYWRlID0gMDtcbiAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG59O1xuTGluay5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFN0YWdlczpcbiAgICAvLyAwLiBWZXJ0ZXggY29sbGVjdGlvblxuICAgIC8vIDEuIFJlbmRlciBsaW5lIHJlYWNoaW5nIGZyb20gdmVydGV4IHRvIHZlcnRleFxuICAgIC8vIDIuIEZhZGUgb3V0XG4gICAgLy8gMy4gRmluaXNoZWQgKGRlbGV0ZSBtZSlcblxuICAgIHZhciBpLCBwLCBwb3MsIHBvaW50cztcblxuICAgIHN3aXRjaCAodGhpcy5zdGFnZSkge1xuICAgICAgICAvLyBWRVJURVggQ09MTEVDVElPTiBTVEFHRVxuICAgICAgICBjYXNlIDA6XG5cbiAgICAgICAgICAgIC8vIEdyYWIgdGhlIGxhc3QgbWVtYmVyIG9mIHRoZSBsaW5rXG4gICAgICAgICAgICB2YXIgbGFzdCA9IHBhcnRpY2xlc1t0aGlzLnZlcnRzW3RoaXMudmVydHMubGVuZ3RoIC0gMV1dO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShsYXN0KSk7XG4gICAgICAgICAgICBpZiAobGFzdCAmJiBsYXN0Lm5laWdoYm9ycyAmJiBsYXN0Lm5laWdoYm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gR3JhYiBhIHJhbmRvbSBuZWlnaGJvclxuICAgICAgICAgICAgICAgIHZhciBuZWlnaGJvciA9IGxhc3QubmVpZ2hib3JzW3JhbmRvbSgwLCBsYXN0Lm5laWdoYm9ycy5sZW5ndGggLSAxKV07XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBzZWVuIHRoYXQgcGFydGljbGUgYmVmb3JlLCBhZGQgaXQgdG8gdGhlIGxpbmtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52ZXJ0cy5pbmRleE9mKG5laWdoYm9yKSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZlcnRzLnB1c2gobmVpZ2hib3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIHNlZW4gdGhhdCBwYXJ0aWNsZSBiZWZvcmUsIHdlJ2xsIGp1c3Qgd2FpdCBmb3IgdGhlIG5leHQgZnJhbWVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLnZlcnRzWzBdKycgcHJlbWF0dXJlbHkgbW92aW5nIHRvIHN0YWdlIDMgKDApJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFnZSA9IDM7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnZlcnRzLmxlbmd0aCA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBhbGwgZGlzdGFuY2VzIGF0IG9uY2VcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy52ZXJ0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAxID0gcGFydGljbGVzW3RoaXMudmVydHNbaV1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgcDIgPSBwYXJ0aWNsZXNbdGhpcy52ZXJ0c1tpICsgMV1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHggPSBwMS54IC0gcDIueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR5ID0gcDEueSAtIHAyLnksXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3RhbmNlcy5wdXNoKGRpc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdEaXN0YW5jZXM6ICcrSlNPTi5zdHJpbmdpZnkodGhpcy5kaXN0YW5jZXMpKTtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd2ZXJ0czogJyt0aGlzLnZlcnRzLmxlbmd0aCsnIGRpc3RhbmNlczogJyt0aGlzLmRpc3RhbmNlcy5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLnZlcnRzWzBdKycgbW92aW5nIHRvIHN0YWdlIDEnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWdlID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIFJFTkRFUiBMSU5FIEFOSU1BVElPTiBTVEFHRVxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBpZiAodGhpcy5kaXN0YW5jZXMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICAgICAgcG9pbnRzID0gW107XG4gICAgICAgICAgICAgICAgLy92YXIgYSA9IDE7XG5cbiAgICAgICAgICAgICAgICAvLyBHYXRoZXIgYWxsIHBvaW50cyBhbHJlYWR5IGxpbmtlZFxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxpbmtlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBwID0gcGFydGljbGVzW3RoaXMubGlua2VkW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zaXRpb24ocC54LCBwLnksIHAueik7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKFtwb3MueCwgcG9zLnldKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbGlua1NwZWVkUmVsID0gbGlua1NwZWVkICogMC4wMDAwMSAqIGNhbnZhcy53aWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYXZlbGVkICs9IGxpbmtTcGVlZFJlbDtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IHRoaXMuZGlzdGFuY2VzW3RoaXMubGlua2VkLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBsYXN0IHBvaW50IGJhc2VkIG9uIGxpbmtTcGVlZCBhbmQgZGlzdGFuY2UgdHJhdmVsbGVkIHRvIG5leHQgcG9pbnRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmF2ZWxlZCA+PSBkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhdmVsZWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBuZXh0IHBvaW50LCBhZGQgY29vcmRpbmF0ZXMgdG8gYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLnZlcnRzWzBdKycgcmVhY2hlZCB2ZXJ0ZXggJysodGhpcy5saW5rZWQubGVuZ3RoKzEpKycgb2YgJyt0aGlzLnZlcnRzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5rZWQucHVzaCh0aGlzLnZlcnRzW3RoaXMubGlua2VkLmxlbmd0aF0pO1xuICAgICAgICAgICAgICAgICAgICBwID0gcGFydGljbGVzW3RoaXMubGlua2VkW3RoaXMubGlua2VkLmxlbmd0aCAtIDFdXTtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zaXRpb24ocC54LCBwLnksIHAueik7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKFtwb3MueCwgcG9zLnldKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5saW5rZWQubGVuZ3RoID49IHRoaXMudmVydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMudmVydHNbMF0rJyBtb3ZpbmcgdG8gc3RhZ2UgMiAoMSknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhZ2UgPSAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UncmUgc3RpbGwgdHJhdmVsbGluZyB0byB0aGUgbmV4dCBwb2ludCwgZ2V0IGNvb3JkaW5hdGVzIGF0IHRyYXZlbCBkaXN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9hLzg1NTgyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gcGFydGljbGVzW3RoaXMubGlua2VkW3RoaXMubGlua2VkLmxlbmd0aCAtIDFdXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBwYXJ0aWNsZXNbdGhpcy52ZXJ0c1t0aGlzLmxpbmtlZC5sZW5ndGhdXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBkIC0gdGhpcy50cmF2ZWxlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSAoKHRoaXMudHJhdmVsZWQgKiBiLngpICsgKHQgKiBhLngpKSAvIGQsXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gKCh0aGlzLnRyYXZlbGVkICogYi55KSArICh0ICogYS55KSkgLyBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgeiA9ICgodGhpcy50cmF2ZWxlZCAqIGIueikgKyAodCAqIGEueikpIC8gZDtcblxuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3NpdGlvbih4LCB5LCB6KTtcblxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMudmVydHNbMF0rJyB0cmF2ZWxpbmcgdG8gdmVydGV4ICcrKHRoaXMubGlua2VkLmxlbmd0aCsxKSsnIG9mICcrdGhpcy52ZXJ0cy5sZW5ndGgrJyAoJyt0aGlzLnRyYXZlbGVkKycgb2YgJyt0aGlzLmRpc3RhbmNlc1t0aGlzLmxpbmtlZC5sZW5ndGhdKycpJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goW3Bvcy54LCBwb3MueV0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0xpbmUocG9pbnRzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLnZlcnRzWzBdKycgcHJlbWF0dXJlbHkgbW92aW5nIHRvIHN0YWdlIDMgKDEpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFnZSA9IDM7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBGQURFIE9VVCBTVEFHRVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBpZiAodGhpcy52ZXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmFkZSA8IGxpbmtGYWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFkZSsrO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbmRlciBmdWxsIGxpbmsgYmV0d2VlbiBhbGwgdmVydGljZXMgYW5kIGZhZGUgb3ZlciB0aW1lXG4gICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWxwaGEgPSAoMSAtICh0aGlzLmZhZGUgLyBsaW5rRmFkZSkpICogbGlua09wYWNpdHk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnZlcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gcGFydGljbGVzW3RoaXMudmVydHNbaV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zaXRpb24ocC54LCBwLnksIHAueik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChbcG9zLngsIHBvcy55XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3TGluZShwb2ludHMsIGFscGhhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMudmVydHNbMF0rJyBtb3ZpbmcgdG8gc3RhZ2UgMyAoMmEpJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhZ2UgPSAzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2codGhpcy52ZXJ0c1swXSsnIHByZW1hdHVyZWx5IG1vdmluZyB0byBzdGFnZSAzICgyYiknKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWdlID0gMztcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIEZJTklTSEVEIFNUQUdFXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcbkxpbmsucHJvdG90eXBlLmRyYXdMaW5lID0gZnVuY3Rpb24gKHBvaW50cywgYWxwaGEpIHtcbiAgICBpZiAodHlwZW9mIGFscGhhICE9PSAnbnVtYmVyJykgYWxwaGEgPSBsaW5rT3BhY2l0eTtcblxuICAgIGlmIChwb2ludHMubGVuZ3RoID4gMSAmJiBhbHBoYSA+IDApIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLnZlcnRzWzBdKyc6IERyYXdpbmcgbGluZSAnK2FscGhhKTtcbiAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHBvaW50c1tpXVswXSwgcG9pbnRzW2ldWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHBvaW50c1tpICsgMV1bMF0sIHBvaW50c1tpICsgMV1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSAxO1xuICAgIH1cbn07XG5cblxuLy8gVXRpbHNcblxuZnVuY3Rpb24gbm9pc2VQb2ludChpKSB7XG4gICAgdmFyIGEgPSBuQW5nbGUgKiBpLFxuICAgICAgICBjb3NBID0gTWF0aC5jb3MoYSksXG4gICAgICAgIHNpbkEgPSBNYXRoLnNpbihhKSxcbiAgICAgICAgLy92YWx1ZSA9IHNpbXBsZXgubm9pc2UyRChuU2NhbGUgKiBjb3NBICsgblNjYWxlLCBuU2NhbGUgKiBzaW5BICsgblNjYWxlKSxcbiAgICAgICAgLy9yYWQgPSBuUmFkICsgdmFsdWU7XG4gICAgICAgIHJhZCA9IG5SYWQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogcmFkICogY29zQSxcbiAgICAgICAgeTogcmFkICogc2luQVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHBvc2l0aW9uKHgsIHksIHopIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiAoeCAqIGNhbnZhcy53aWR0aCkgKyAoKCgoY2FudmFzLndpZHRoIC8gMikgLSBtb3VzZS54ICsgKChuUG9zLnggLSAwLjUpICogbm9pc2VTdHJlbmd0aCkpICogeikgKiBtb3Rpb24pLFxuICAgICAgICB5OiAoeSAqIGNhbnZhcy5oZWlnaHQpICsgKCgoKGNhbnZhcy5oZWlnaHQgLyAyKSAtIG1vdXNlLnkgKyAoKG5Qb3MueSAtIDAuNSkgKiBub2lzZVN0cmVuZ3RoKSkgKiB6KSAqIG1vdGlvbilcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBzaXplUmF0aW8oKSB7XG4gICAgcmV0dXJuIGNhbnZhcy53aWR0aCA+PSBjYW52YXMuaGVpZ2h0ID8gY2FudmFzLndpZHRoIDogY2FudmFzLmhlaWdodDtcbn1cblxuZnVuY3Rpb24gcmFuZG9tKG1pbiwgbWF4LCBmbG9hdCkge1xuICAgIHJldHVybiBmbG9hdCA/XG4gICAgICAgIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbiA6XG4gICAgICAgIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XG59XG5cblxuLy8gaW5pdFxuaWYgKGNhbnZhcykgaW5pdCgpOyJdLCJuYW1lcyI6WyJwYXJ0aWNsZUNvdW50IiwiZmxhcmVDb3VudCIsIm1vdGlvbiIsInRpbHQiLCJjb2xvciIsInBhcnRpY2xlU2l6ZUJhc2UiLCJwYXJ0aWNsZVNpemVNdWx0aXBsaWVyIiwiZmxhcmVTaXplQmFzZSIsImZsYXJlU2l6ZU11bHRpcGxpZXIiLCJsaW5lV2lkdGgiLCJsaW5rQ2hhbmNlIiwibGlua0xlbmd0aE1pbiIsImxpbmtMZW5ndGhNYXgiLCJsaW5rT3BhY2l0eSIsImxpbmtGYWRlIiwibGlua1NwZWVkIiwiZ2xhcmVBbmdsZSIsImdsYXJlT3BhY2l0eU11bHRpcGxpZXIiLCJyZW5kZXJQYXJ0aWNsZXMiLCJyZW5kZXJQYXJ0aWNsZUdsYXJlIiwicmVuZGVyRmxhcmVzIiwicmVuZGVyTGlua3MiLCJyZW5kZXJNZXNoIiwiZmxpY2tlciIsImZsaWNrZXJTbW9vdGhpbmciLCJibHVyU2l6ZSIsIm9yYml0VGlsdCIsInJhbmRvbU1vdGlvbiIsIm5vaXNlTGVuZ3RoIiwibm9pc2VTdHJlbmd0aCIsImNhbnZhcyIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJjb250ZXh0IiwiZ2V0Q29udGV4dCIsIm1vdXNlIiwieCIsInkiLCJtIiwiciIsImMiLCJuIiwibkFuZ2xlIiwiTWF0aCIsIlBJIiwiblJhZCIsIm5TY2FsZSIsIm5Qb3MiLCJwb2ludHMiLCJ2ZXJ0aWNlcyIsInRyaWFuZ2xlcyIsImxpbmtzIiwicGFydGljbGVzIiwiZmxhcmVzIiwiaW5pdCIsImkiLCJqIiwiayIsIndpbmRvdyIsInJlcXVlc3RBbmltRnJhbWUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYWxsYmFjayIsInNldFRpbWVvdXQiLCJyZXNpemUiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsInAiLCJQYXJ0aWNsZSIsInB1c2giLCJEZWxhdW5heSIsInJlcXVpcmUiLCJ0cmlhbmd1bGF0ZSIsInRyaSIsImxlbmd0aCIsImluZGV4T2YiLCJmb3JFYWNoIiwidmFsdWUiLCJpbmRleCIsImFycmF5IiwibmVpZ2hib3JzIiwiRmxhcmUiLCJkb2N1bWVudEVsZW1lbnQiLCJEZXZpY2VPcmllbnRhdGlvbkV2ZW50IiwiY29uc29sZSIsImxvZyIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwiZ2FtbWEiLCJiZXRhIiwiYm9keSIsImNsaWVudFgiLCJjbGllbnRZIiwiYW5pbWxvb3AiLCJyZW5kZXIiLCJub2lzZVBvaW50IiwiY2xlYXJSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJzaGFkb3dCbHVyIiwic2hhZG93Q29sb3IiLCJiZWdpblBhdGgiLCJ2IiwicDEiLCJwMiIsInBvczEiLCJwb3NpdGlvbiIsInoiLCJwb3MyIiwibW92ZVRvIiwibGluZVRvIiwic3Ryb2tlU3R5bGUiLCJzdHJva2UiLCJjbG9zZVBhdGgiLCJyYW5kb20iLCJzdGFydCIsInN0YXJ0TGluayIsImwiLCJmaW5pc2hlZCIsImlubmVyV2lkdGgiLCJkZXZpY2VQaXhlbFJhdGlvIiwidmVydGV4IiwiTGluayIsIm9wYWNpdHkiLCJwcm90b3R5cGUiLCJwb3MiLCJzaXplUmF0aW8iLCJvIiwibmV3VmFsIiwiZmlsbFN0eWxlIiwiZ2xvYmFsQWxwaGEiLCJhcmMiLCJmaWxsIiwiZWxsaXBzZSIsInN0YXJ0VmVydGV4IiwibnVtUG9pbnRzIiwidmVydHMiLCJzdGFnZSIsImxpbmtlZCIsImRpc3RhbmNlcyIsInRyYXZlbGVkIiwiZmFkZSIsImxhc3QiLCJuZWlnaGJvciIsImR4IiwiZHkiLCJkaXN0Iiwic3FydCIsImxpbmtTcGVlZFJlbCIsImQiLCJhIiwiYiIsInQiLCJkcmF3TGluZSIsImFscGhhIiwiY29zQSIsImNvcyIsInNpbkEiLCJzaW4iLCJyYWQiLCJtaW4iLCJtYXgiLCJmbG9hdCIsImZsb29yIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/background.js\n"));

/***/ })

}]);